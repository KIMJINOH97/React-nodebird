{"ast":null,"code":"var __jsx = React.createElement;\nimport React from 'react';\nimport Head from 'next/head';\nimport AppLayout from '../components/AppLayout';\nimport PropTypes from 'prop-types';\nimport wrapper from '../store/configureStore'; // 모든 파일들이 부모 component로 사용한다.\n// app.js 는 모든 페이지에 공통적으로 적용 됨. 중앙 통제실도 redux를 연결 해줘야함 app.js가 공유하기 때문에\n// store을 넣어 줄게 없으므로 npm i next-redux-wrapper로 해준다.\n\nconst Nodebird = ({\n  Component,\n  pageProps,\n  store\n}) => {\n  // props로 Component를 받는다.\n  return (// store 는 리덕스 state임 자식 component는 중앙통제실 state를 다 받는 거임 최상위 부모이기 때문\n    __jsx(React.Fragment, null, __jsx(Head, null, __jsx(\"title\", null, \"Node bird\"), __jsx(\"link\", {\n      rel: \"stylesheet\",\n      href: \"https://cdnjs.cloudflare.com/ajax/libs/antd/3.16.2/antd.css\"\n    }), __jsx(\"script\", {\n      src: \"https://cdnjs.cloudflare.com/ajax/libs/antd/3.16.2/antd.js\"\n    })), __jsx(AppLayout, null, __jsx(Component, null)))\n  );\n}; // 부모로부터 올바른 자료형을 받았는지 확인\n\n\nNodebird.propTypes = {\n  Component: PropTypes.elementType.isRequired // 노드로 가능한 것 : 랜더링으로 할 수 있는 모든 것 tag 쓰는 애들 >> elementType\n\n};\n\nNodebird.getInitialProps = async context => {\n  // next에서 context를 내려줌\n  // geinitialprops 실행 위함.\n  console.log(context);\n  const {\n    ctx\n  } = context;\n  let pageProps = {};\n\n  if (context.Component.getInitialProps) {\n    pageProps = await context.Component.getInitialProps(ctx); // nodebird안의 component에 추가\n  }\n\n  return {\n    pageProps\n  }; // component의 props가 됨\n};\n\nexport default wrapper.withRedux(Nodebird); // 고위 컴퍼넌트라고 부름 기존 컴퍼넌트의 기능을 확장해줌.\n// export default withRedux((initialState, options) => {\n//     const store = createStore(reducer, initialState);\n//     // 리듀서들을 만들었는데(state들이 어떻게 동작하는지) 이 위의것 두개 합친게 store\n//     // 여기에다가 store 커스터마이징\n//     return store;\n// })(Nodebird);\n// 노드버드에 store을 props로 넣어준다고 생각하면 됨\n// hot(NumberBaseBall); 실시간으로 업데이트 가능한 기능","map":{"version":3,"sources":["C:/react-nodebird/nodebird/front/pages/_app.js"],"names":["React","Head","AppLayout","PropTypes","wrapper","Nodebird","Component","pageProps","store","propTypes","elementType","isRequired","getInitialProps","context","console","log","ctx","withRedux"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,IAAP,MAAiB,WAAjB;AACA,OAAOC,SAAP,MAAsB,yBAAtB;AACA,OAAOC,SAAP,MAAsB,YAAtB;AACA,OAAOC,OAAP,MAAoB,yBAApB,C,CACA;AACA;AAEA;;AACA,MAAMC,QAAQ,GAAG,CAAC;AAAEC,EAAAA,SAAF;AAAaC,EAAAA,SAAb;AAAwBC,EAAAA;AAAxB,CAAD,KAAqC;AAClD;AACA,SACI;AACA,gCACI,MAAC,IAAD,QACI,iCADJ,EAEI;AAAM,MAAA,GAAG,EAAC,YAAV;AAAuB,MAAA,IAAI,EAAC;AAA5B,MAFJ,EAGI;AAAQ,MAAA,GAAG,EAAC;AAAZ,MAHJ,CADJ,EAMI,MAAC,SAAD,QACI,MAAC,SAAD,OADJ,CANJ;AAFJ;AAaH,CAfD,C,CAgBA;;;AACAH,QAAQ,CAACI,SAAT,GAAqB;AACjBH,EAAAA,SAAS,EAAEH,SAAS,CAACO,WAAV,CAAsBC,UADhB,CAC4B;;AAD5B,CAArB;;AAIAN,QAAQ,CAACO,eAAT,GAA2B,MAAOC,OAAP,IAAmB;AAC1C;AACA;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAYF,OAAZ;AACA,QAAM;AAAEG,IAAAA;AAAF,MAAUH,OAAhB;AACA,MAAIN,SAAS,GAAG,EAAhB;;AACA,MAAIM,OAAO,CAACP,SAAR,CAAkBM,eAAtB,EAAuC;AACnCL,IAAAA,SAAS,GAAG,MAAMM,OAAO,CAACP,SAAR,CAAkBM,eAAlB,CAAkCI,GAAlC,CAAlB,CADmC,CACuB;AAC7D;;AACD,SAAO;AAAET,IAAAA;AAAF,GAAP,CAT0C,CASpB;AACzB,CAVD;;AAYA,eAAeH,OAAO,CAACa,SAAR,CAAkBZ,QAAlB,CAAf,C,CACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA","sourcesContent":["import React from 'react';\r\nimport Head from 'next/head';\r\nimport AppLayout from '../components/AppLayout';\r\nimport PropTypes from 'prop-types';\r\nimport wrapper from '../store/configureStore';\r\n// 모든 파일들이 부모 component로 사용한다.\r\n// app.js 는 모든 페이지에 공통적으로 적용 됨. 중앙 통제실도 redux를 연결 해줘야함 app.js가 공유하기 때문에\r\n\r\n// store을 넣어 줄게 없으므로 npm i next-redux-wrapper로 해준다.\r\nconst Nodebird = ({ Component, pageProps, store }) => {\r\n    // props로 Component를 받는다.\r\n    return (\r\n        // store 는 리덕스 state임 자식 component는 중앙통제실 state를 다 받는 거임 최상위 부모이기 때문\r\n        <>\r\n            <Head>\r\n                <title>Node bird</title>\r\n                <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/antd/3.16.2/antd.css\" />\r\n                <script src=\"https://cdnjs.cloudflare.com/ajax/libs/antd/3.16.2/antd.js\" />\r\n            </Head>\r\n            <AppLayout>\r\n                <Component />\r\n            </AppLayout>\r\n        </>\r\n    );\r\n};\r\n// 부모로부터 올바른 자료형을 받았는지 확인\r\nNodebird.propTypes = {\r\n    Component: PropTypes.elementType.isRequired, // 노드로 가능한 것 : 랜더링으로 할 수 있는 모든 것 tag 쓰는 애들 >> elementType\r\n};\r\n\r\nNodebird.getInitialProps = async (context) => {\r\n    // next에서 context를 내려줌\r\n    // geinitialprops 실행 위함.\r\n    console.log(context);\r\n    const { ctx } = context;\r\n    let pageProps = {};\r\n    if (context.Component.getInitialProps) {\r\n        pageProps = await context.Component.getInitialProps(ctx); // nodebird안의 component에 추가\r\n    }\r\n    return { pageProps }; // component의 props가 됨\r\n};\r\n\r\nexport default wrapper.withRedux(Nodebird);\r\n// 고위 컴퍼넌트라고 부름 기존 컴퍼넌트의 기능을 확장해줌.\r\n// export default withRedux((initialState, options) => {\r\n//     const store = createStore(reducer, initialState);\r\n//     // 리듀서들을 만들었는데(state들이 어떻게 동작하는지) 이 위의것 두개 합친게 store\r\n//     // 여기에다가 store 커스터마이징\r\n//     return store;\r\n// })(Nodebird);\r\n// 노드버드에 store을 props로 넣어준다고 생각하면 됨\r\n\r\n// hot(NumberBaseBall); 실시간으로 업데이트 가능한 기능\r\n"]},"metadata":{},"sourceType":"module"}